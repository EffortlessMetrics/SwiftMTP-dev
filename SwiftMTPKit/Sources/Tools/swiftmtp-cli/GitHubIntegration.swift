// SPDX-License-Identifier: AGPL-3.0-only
// Copyright (c) 2025 Effortless Metrics, Inc.

import Foundation

/// Utility for GitHub CLI integration
struct GitHubIntegration {
    /// Check if GitHub CLI is installed
    static func isGitHubCLIInstalled() async -> Bool {
        do {
            let result = try await runCommand("which", arguments: ["gh"])
            return !result.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty
        } catch {
            return false
        }
    }

    /// Check if user is authenticated with GitHub CLI
    static func isGitHubCLIAuthenticated() async -> Bool {
        do {
            let result = try await runCommand("gh", arguments: ["auth", "status"])
            return result.contains("Logged in")
        } catch {
            return false
        }
    }

    /// Get the current GitHub repository information
    static func getRepositoryInfo() async throws -> (owner: String, name: String) {
        let result = try await runCommand("gh", arguments: ["repo", "view", "--json", "owner,name"])
        // Parse JSON response
        guard let data = result.data(using: .utf8),
              let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any],
              let owner = json["owner"] as? [String: Any],
              let ownerLogin = owner["login"] as? String,
              let name = json["name"] as? String else {
            throw GitHubError.parsingError("Failed to parse repository info")
        }
        return (ownerLogin, name)
    }

    /// Create a branch for the device submission
    static func createBranch(name: String) async throws {
        try await runCommand("git", arguments: ["checkout", "-b", name])
    }

    /// Add files to git
    static func addFiles(paths: [String]) async throws {
        let args = ["add"] + paths
        try await runCommand("git", arguments: args)
    }

    /// Commit changes
    static func commitChanges(message: String) async throws {
        try await runCommand("git", arguments: ["commit", "-s", "-m", message])
    }

    /// Push branch to remote
    static func pushBranch(branchName: String) async throws {
        try await runCommand("git", arguments: ["push", "-u", "origin", branchName])
    }

    /// Create a pull request
    static func createPullRequest(title: String, body: String, fill: Bool = true) async throws {
        var args = ["pr", "create", "--title", title, "--body", body]
        if fill {
            args.append("--fill")
        }
        try await runCommand("gh", arguments: args)
    }

    /// Generate a PR body for device submission
    static func generatePRBody(deviceName: String, vendorId: String, productId: String, bundlePath: String) -> String {
        return """
        ## Device Submission

        **Device:** \(deviceName)
        **VID:PID:** \(vendorId):\(productId)

        ### Files Changed
        - `\(bundlePath)/` - Device submission bundle

        ### Checklist
        - [x] Device probe data collected
        - [x] USB dump captured
        - [x] Serial numbers redacted
        - [x] Quirk suggestion generated
        - [ ] Submission validated locally

        ---
        *Generated by SwiftMTP collect command*
        """
    }

    /// Generate a standardized branch name for device submissions
    static func generateBranchName(deviceName: String, vendorId: String, productId: String) -> String {
        let sanitizedDeviceName = deviceName
            .lowercased()
            .replacingOccurrences(of: " ", with: "-")
            .replacingOccurrences(of: "[^a-z0-9-]", with: "-", options: .regularExpression)
            .replacingOccurrences(of: "-+", with: "-", options: .regularExpression)
            .trimmingCharacters(in: CharacterSet(charactersIn: "-"))

        let timestamp = Int(Date().timeIntervalSince1970)
        return "device/\(sanitizedDeviceName)-\(vendorId)-\(productId)-\(timestamp)"
    }

    /// Generate a standardized commit message for device submissions
    static func generateCommitMessage(deviceName: String, vendorId: String, productId: String) -> String {
        return "Device submission: \(deviceName) (\(vendorId):\(productId))"
    }

    /// Run a shell command and return its output
    private static func runCommand(_ command: String, arguments: [String]) async throws -> String {
        let process = Process()
        process.executableURL = URL(fileURLWithPath: "/usr/bin/\(command)")
        process.arguments = arguments

        let pipe = Pipe()
        process.standardOutput = pipe
        process.standardError = Pipe()

        try process.run()
        process.waitUntilExit()

        if process.terminationStatus != 0 {
            let errorData = pipe.fileHandleForReading.readDataToEndOfFile()
            let errorMessage = String(data: errorData, encoding: .utf8) ?? "Unknown error"
            throw GitHubError.commandFailed("Command '\(command) \(arguments.joined(separator: " "))' failed: \(errorMessage)")
        }

        let data = pipe.fileHandleForReading.readDataToEndOfFile()
        return String(data: data, encoding: .utf8) ?? ""
    }

    enum GitHubError: Error {
        case parsingError(String)
        case commandFailed(String)
    }
}
